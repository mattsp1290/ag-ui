package monitoring

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/ag-ui/go-sdk/pkg/core/events"
	"github.com/prometheus/client_golang/prometheus"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/propagation"
	sdkmetric "go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// MonitoringIntegration provides enterprise-grade monitoring capabilities
type MonitoringIntegration struct {
	config            *Config
	metricsCollector  events.MetricsCollector
	prometheusExporter *PrometheusExporter
	alertManager      *AlertManager
	grafanaGenerator  *GrafanaDashboardGenerator
	
	// OpenTelemetry components
	tracerProvider *sdktrace.TracerProvider
	meterProvider  metric.MeterProvider
	tracer         trace.Tracer
	meter          metric.Meter
	
	// Custom collectors
	customCollectors []prometheus.Collector
	
	// Performance SLA monitoring
	slaMonitor *SLAMonitor
	
	// Lifecycle management
	ctx    context.Context
	cancel context.CancelFunc
	wg     sync.WaitGroup
}

// Config holds the configuration for monitoring integration
type Config struct {
	// Base metrics configuration
	MetricsConfig *events.MetricsConfig
	
	// Prometheus configuration
	PrometheusPort     int
	PrometheusPath     string
	EnableCustomLabels bool
	CustomLabels       map[string]string
	
	// OpenTelemetry configuration
	OTLPEndpoint      string
	OTLPHeaders       map[string]string
	TraceSampleRate   float64
	EnableTracing     bool
	EnableMetrics     bool
	ServiceName       string
	ServiceVersion    string
	Environment       string
	
	// Alerting configuration
	AlertRulesPath    string
	AlertWebhookURL   string
	AlertThresholds   AlertThresholds
	EnableRunbooks    bool
	RunbookBaseURL    string
	
	// SLA configuration
	SLATargets        map[string]SLATarget
	SLAWindowSize     time.Duration
	EnableSLAReports  bool
	
	// Dashboard configuration
	GrafanaURL        string
	GrafanaAPIKey     string
	AutoGenerateDash  bool
	DashboardTemplates []string
}

// AlertThresholds defines thresholds for various alert conditions
type AlertThresholds struct {
	ErrorRatePercent      float64
	LatencyP99Millis      float64
	MemoryUsagePercent    float64
	ThroughputMinEvents   float64
	RuleExecutionP99Millis float64
	SLAViolationPercent   float64
}

// SLATarget defines a Service Level Agreement target
type SLATarget struct {
	Name              string
	Description       string
	TargetValue       float64
	Unit              string
	MeasurementWindow time.Duration
	AlertOnViolation  bool
}

// DefaultConfig returns a default monitoring configuration
func DefaultConfig() *Config {
	return &Config{
		MetricsConfig:      events.ProductionMetricsConfig(),
		PrometheusPort:     9090,
		PrometheusPath:     "/metrics",
		EnableCustomLabels: true,
		CustomLabels: map[string]string{
			"component": "event-validation",
		},
		OTLPEndpoint:    "localhost:4317",
		TraceSampleRate: 0.1,
		EnableTracing:   true,
		EnableMetrics:   true,
		ServiceName:     "ag-ui-events",
		ServiceVersion:  "1.0.0",
		Environment:     "production",
		AlertThresholds: AlertThresholds{
			ErrorRatePercent:       5.0,
			LatencyP99Millis:       100.0,
			MemoryUsagePercent:     80.0,
			ThroughputMinEvents:    100.0,
			RuleExecutionP99Millis: 50.0,
			SLAViolationPercent:    10.0,
		},
		SLATargets: map[string]SLATarget{
			"validation_latency": {
				Name:              "Event Validation Latency",
				Description:       "99th percentile latency for event validation",
				TargetValue:       100.0,
				Unit:              "milliseconds",
				MeasurementWindow: 5 * time.Minute,
				AlertOnViolation:  true,
			},
			"throughput": {
				Name:              "Event Processing Throughput",
				Description:       "Minimum events processed per second",
				TargetValue:       1000.0,
				Unit:              "events/second",
				MeasurementWindow: 1 * time.Minute,
				AlertOnViolation:  true,
			},
			"error_rate": {
				Name:              "Validation Error Rate",
				Description:       "Maximum acceptable error rate",
				TargetValue:       1.0,
				Unit:              "percent",
				MeasurementWindow: 5 * time.Minute,
				AlertOnViolation:  true,
			},
		},
		SLAWindowSize:    5 * time.Minute,
		EnableSLAReports: true,
		EnableRunbooks:   true,
		RunbookBaseURL:   "https://runbooks.example.com",
		AutoGenerateDash: true,
	}
}

// NewMonitoringIntegration creates a new monitoring integration
func NewMonitoringIntegration(config *Config) (*MonitoringIntegration, error) {
	if config == nil {
		config = DefaultConfig()
	}
	
	ctx, cancel := context.WithCancel(context.Background())
	
	// Create base metrics collector
	metricsCollector, err := events.NewMetricsCollector(config.MetricsConfig)
	if err != nil {
		cancel()
		return nil, fmt.Errorf("failed to create metrics collector: %w", err)
	}
	
	m := &MonitoringIntegration{
		config:           config,
		metricsCollector: metricsCollector,
		ctx:              ctx,
		cancel:           cancel,
		customCollectors: make([]prometheus.Collector, 0),
	}
	
	// Initialize OpenTelemetry
	if err := m.initializeOpenTelemetry(); err != nil {
		cancel()
		return nil, fmt.Errorf("failed to initialize OpenTelemetry: %w", err)
	}
	
	// Initialize Prometheus exporter
	m.prometheusExporter = NewPrometheusExporter(config, metricsCollector)
	
	// Initialize alert manager
	m.alertManager = NewAlertManager(config, metricsCollector)
	
	// Initialize Grafana dashboard generator
	m.grafanaGenerator = NewGrafanaDashboardGenerator(config)
	
	// Initialize SLA monitor
	m.slaMonitor = NewSLAMonitor(config, metricsCollector)
	
	// Register custom collectors
	m.registerCustomCollectors()
	
	// Start background tasks
	m.startBackgroundTasks()
	
	return m, nil
}

// initializeOpenTelemetry sets up OpenTelemetry tracing and metrics
func (m *MonitoringIntegration) initializeOpenTelemetry() error {
	if m.config.EnableTracing {
		// Create OTLP trace exporter
		opts := []otlptracegrpc.Option{
			otlptracegrpc.WithEndpoint(m.config.OTLPEndpoint),
			otlptracegrpc.WithDialOption(grpc.WithTransportCredentials(insecure.NewCredentials())),
		}
		
		if len(m.config.OTLPHeaders) > 0 {
			opts = append(opts, otlptracegrpc.WithHeaders(m.config.OTLPHeaders))
		}
		
		exporter, err := otlptrace.New(m.ctx, otlptracegrpc.NewClient(opts...))
		if err != nil {
			return fmt.Errorf("failed to create OTLP trace exporter: %w", err)
		}
		
		// Create tracer provider
		m.tracerProvider = sdktrace.NewTracerProvider(
			sdktrace.WithBatcher(exporter),
			sdktrace.WithSampler(sdktrace.TraceIDRatioBased(m.config.TraceSampleRate)),
			sdktrace.WithResource(m.createResource()),
		)
		
		// Set global tracer provider
		otel.SetTracerProvider(m.tracerProvider)
		otel.SetTextMapPropagator(propagation.TraceContext{})
		
		// Create tracer
		m.tracer = m.tracerProvider.Tracer(m.config.ServiceName)
	}
	
	if m.config.EnableMetrics {
		// Create meter provider
		meterProvider := sdkmetric.NewMeterProvider(
			sdkmetric.WithResource(m.createResource()),
		)
		
		// Set global meter provider
		otel.SetMeterProvider(meterProvider)
		m.meterProvider = meterProvider
		
		// Create meter
		m.meter = m.meterProvider.Meter(m.config.ServiceName)
	}
	
	return nil
}

// createResource creates OpenTelemetry resource attributes
func (m *MonitoringIntegration) createResource() *resource.Resource {
	return resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String(m.config.ServiceName),
		semconv.ServiceVersionKey.String(m.config.ServiceVersion),
		semconv.DeploymentEnvironmentKey.String(m.config.Environment),
	)
}

// registerCustomCollectors registers Prometheus custom collectors
func (m *MonitoringIntegration) registerCustomCollectors() {
	// Event validation collector
	eventCollector := NewEventValidationCollector(m.metricsCollector, m.config.CustomLabels)
	m.customCollectors = append(m.customCollectors, eventCollector)
	prometheus.MustRegister(eventCollector)
	
	// Rule execution collector
	ruleCollector := NewRuleExecutionCollector(m.metricsCollector, m.config.CustomLabels)
	m.customCollectors = append(m.customCollectors, ruleCollector)
	prometheus.MustRegister(ruleCollector)
	
	// SLA compliance collector
	slaCollector := NewSLAComplianceCollector(m.slaMonitor, m.config.CustomLabels)
	m.customCollectors = append(m.customCollectors, slaCollector)
	prometheus.MustRegister(slaCollector)
	
	// Memory usage collector
	memoryCollector := NewMemoryUsageCollector(m.metricsCollector, m.config.CustomLabels)
	m.customCollectors = append(m.customCollectors, memoryCollector)
	prometheus.MustRegister(memoryCollector)
}

// startBackgroundTasks starts all background monitoring tasks
func (m *MonitoringIntegration) startBackgroundTasks() {
	// Start Prometheus exporter
	m.wg.Add(1)
	go func() {
		defer m.wg.Done()
		if err := m.prometheusExporter.Start(); err != nil {
			fmt.Printf("Prometheus exporter error: %v\n", err)
		}
	}()
	
	// Start alert manager
	m.wg.Add(1)
	go func() {
		defer m.wg.Done()
		m.alertManager.Start(m.ctx)
	}()
	
	// Start SLA monitor
	m.wg.Add(1)
	go func() {
		defer m.wg.Done()
		m.slaMonitor.Start(m.ctx)
	}()
	
	// Auto-generate Grafana dashboards if enabled
	if m.config.AutoGenerateDash {
		m.wg.Add(1)
		go func() {
			defer m.wg.Done()
			m.autoGenerateDashboards()
		}()
	}
}

// autoGenerateDashboards automatically generates and uploads Grafana dashboards
func (m *MonitoringIntegration) autoGenerateDashboards() {
	ticker := time.NewTicker(time.Hour)
	defer ticker.Stop()
	
	// Generate initial dashboards
	m.generateAndUploadDashboards()
	
	for {
		select {
		case <-m.ctx.Done():
			return
		case <-ticker.C:
			m.generateAndUploadDashboards()
		}
	}
}

// generateAndUploadDashboards generates and uploads dashboards to Grafana
func (m *MonitoringIntegration) generateAndUploadDashboards() {
	dashboards := []struct {
		name string
		gen  func() (*GrafanaDashboard, error)
	}{
		{"Event Validation Overview", m.grafanaGenerator.GenerateOverviewDashboard},
		{"Rule Performance", m.grafanaGenerator.GenerateRulePerformanceDashboard},
		{"SLA Compliance", m.grafanaGenerator.GenerateSLAComplianceDashboard},
		{"System Health", m.grafanaGenerator.GenerateSystemHealthDashboard},
	}
	
	for _, d := range dashboards {
		dashboard, err := d.gen()
		if err != nil {
			fmt.Printf("Failed to generate %s dashboard: %v\n", d.name, err)
			continue
		}
		
		if m.config.GrafanaURL != "" && m.config.GrafanaAPIKey != "" {
			if err := m.grafanaGenerator.UploadDashboard(dashboard); err != nil {
				fmt.Printf("Failed to upload %s dashboard: %v\n", d.name, err)
			}
		}
	}
}

// RecordEventWithContext records an event with OpenTelemetry context
func (m *MonitoringIntegration) RecordEventWithContext(ctx context.Context, duration time.Duration, success bool, attributes map[string]string) {
	// Create span if tracing is enabled
	if m.tracer != nil {
		_, span := m.tracer.Start(ctx, "event.validation",
			trace.WithAttributes(convertAttributes(attributes)...),
		)
		defer span.End()
		
		if !success {
			span.RecordError(fmt.Errorf("validation failed"))
		}
		
		span.SetAttributes(
			attribute.Bool("success", success),
			attribute.Int64("duration_ms", duration.Milliseconds()),
		)
	}
	
	// Record in base metrics collector
	m.metricsCollector.RecordEvent(duration, success)
	
	// Update SLA monitor
	m.slaMonitor.RecordEvent(duration, success)
}

// RecordRuleExecutionWithContext records rule execution with context
func (m *MonitoringIntegration) RecordRuleExecutionWithContext(ctx context.Context, ruleID string, duration time.Duration, success bool) {
	// Create span if tracing is enabled
	if m.tracer != nil {
		_, span := m.tracer.Start(ctx, "rule.execution",
			trace.WithAttributes(
				attribute.String("rule.id", ruleID),
			),
		)
		defer span.End()
		
		if !success {
			span.RecordError(fmt.Errorf("rule execution failed"))
		}
		
		span.SetAttributes(
			attribute.Bool("success", success),
			attribute.Int64("duration_ms", duration.Milliseconds()),
		)
	}
	
	// Record in base metrics collector
	m.metricsCollector.RecordRuleExecution(ruleID, duration, success)
	
	// Update SLA monitor
	m.slaMonitor.RecordRuleExecution(ruleID, duration, success)
}

// GetEnhancedDashboardData returns enhanced dashboard data with SLA information
func (m *MonitoringIntegration) GetEnhancedDashboardData() *EnhancedDashboardData {
	baseDashboard := m.metricsCollector.GetDashboardData()
	slaStatus := m.slaMonitor.GetCurrentStatus()
	activeAlerts := m.alertManager.GetActiveAlerts()
	
	return &EnhancedDashboardData{
		DashboardData: baseDashboard,
		SLAStatus:     slaStatus,
		ActiveAlerts:  activeAlerts,
		Runbooks:      m.getRelevantRunbooks(activeAlerts),
	}
}

// getRelevantRunbooks returns runbooks for active alerts
func (m *MonitoringIntegration) getRelevantRunbooks(alerts []Alert) []Runbook {
	if !m.config.EnableRunbooks {
		return nil
	}
	
	runbooks := make([]Runbook, 0, len(alerts))
	for _, alert := range alerts {
		runbook := Runbook{
			AlertName:   alert.Name,
			Description: alert.Description,
			URL:         fmt.Sprintf("%s/%s", m.config.RunbookBaseURL, alert.RunbookID),
			Steps:       getRunbookSteps(alert.Name),
		}
		runbooks = append(runbooks, runbook)
	}
	
	return runbooks
}

// Shutdown gracefully shuts down the monitoring integration
func (m *MonitoringIntegration) Shutdown() error {
	// Cancel context to stop background tasks
	m.cancel()
	
	// Wait for background tasks to complete
	m.wg.Wait()
	
	// Shutdown components
	if err := m.prometheusExporter.Shutdown(); err != nil {
		return fmt.Errorf("failed to shutdown Prometheus exporter: %w", err)
	}
	
	if err := m.alertManager.Shutdown(); err != nil {
		return fmt.Errorf("failed to shutdown alert manager: %w", err)
	}
	
	if m.tracerProvider != nil {
		if err := m.tracerProvider.Shutdown(context.Background()); err != nil {
			return fmt.Errorf("failed to shutdown tracer provider: %w", err)
		}
	}
	
	// Shutdown base metrics collector
	return m.metricsCollector.Shutdown()
}

// Helper functions

func convertAttributes(attrs map[string]string) []attribute.KeyValue {
	result := make([]attribute.KeyValue, 0, len(attrs))
	for k, v := range attrs {
		result = append(result, attribute.String(k, v))
	}
	return result
}

func getRunbookSteps(alertName string) []string {
	// This would typically be loaded from a configuration file or database
	runbookSteps := map[string][]string{
		"high_error_rate": {
			"1. Check application logs for error patterns",
			"2. Verify upstream dependencies are healthy",
			"3. Check for recent deployments or configuration changes",
			"4. Scale up if load-related",
			"5. Rollback if deployment-related",
		},
		"high_latency": {
			"1. Check current load and throughput",
			"2. Verify database query performance",
			"3. Check for slow validation rules",
			"4. Monitor CPU and memory usage",
			"5. Consider horizontal scaling",
		},
		"memory_pressure": {
			"1. Check for memory leaks in application",
			"2. Analyze heap dumps if available",
			"3. Review recent code changes",
			"4. Increase memory limits if needed",
			"5. Restart affected instances",
		},
		"sla_violation": {
			"1. Identify which SLA target is violated",
			"2. Check system metrics and logs",
			"3. Review recent changes",
			"4. Implement immediate mitigation",
			"5. Create incident report",
		},
	}
	
	if steps, exists := runbookSteps[alertName]; exists {
		return steps
	}
	
	return []string{
		"1. Check system logs",
		"2. Review metrics dashboard",
		"3. Contact on-call engineer",
	}
}

// Data structures

// EnhancedDashboardData extends the base dashboard with monitoring-specific data
type EnhancedDashboardData struct {
	*events.DashboardData
	SLAStatus    map[string]*SLAStatus `json:"sla_status"`
	ActiveAlerts []Alert               `json:"active_alerts"`
	Runbooks     []Runbook            `json:"runbooks"`
}

// Alert represents an active alert
type Alert struct {
	Name        string            `json:"name"`
	Severity    string            `json:"severity"`
	Description string            `json:"description"`
	TriggeredAt time.Time         `json:"triggered_at"`
	Labels      map[string]string `json:"labels"`
	RunbookID   string            `json:"runbook_id"`
}

// Runbook represents a runbook for an alert
type Runbook struct {
	AlertName   string   `json:"alert_name"`
	Description string   `json:"description"`
	URL         string   `json:"url"`
	Steps       []string `json:"steps"`
}

// SLAStatus represents the current status of an SLA target
type SLAStatus struct {
	Target           SLATarget     `json:"target"`
	CurrentValue     float64       `json:"current_value"`
	IsViolated       bool          `json:"is_violated"`
	ViolationPercent float64       `json:"violation_percent"`
	LastUpdated      time.Time     `json:"last_updated"`
	TrendDirection   string        `json:"trend_direction"`
	WindowData       []SLADataPoint `json:"window_data"`
}

// SLADataPoint represents a single data point in the SLA window
type SLADataPoint struct {
	Timestamp time.Time `json:"timestamp"`
	Value     float64   `json:"value"`
	Violated  bool      `json:"violated"`
}