package transport_test

import (
	"context"
	"fmt"
	"sync"
	"testing"
	"time"

	"github.com/ag-ui/go-sdk/pkg/core"
	"github.com/ag-ui/go-sdk/pkg/transport"
	"github.com/ag-ui/go-sdk/pkg/transport/capabilities"
	"github.com/ag-ui/go-sdk/pkg/transport/config"
	"github.com/ag-ui/go-sdk/pkg/transport/factory"
	"github.com/ag-ui/go-sdk/pkg/transport/middleware"
)

// MockTransport implements a mock transport for testing
type MockTransport struct {
	mu              sync.RWMutex
	name            string
	connected       bool
	capabilities    transport.Capabilities
	eventChan       chan transport.Event
	errorChan       chan error
	sentEvents      []core.Event
	shouldFailAfter int
	sendCount       int
	middleware      []transport.Middleware
}

// NewMockTransport creates a new mock transport
func NewMockTransport(name string, caps transport.Capabilities) *MockTransport {
	return &MockTransport{
		name:         name,
		capabilities: caps,
		eventChan:    make(chan transport.Event, 100),
		errorChan:    make(chan error, 100),
		sentEvents:   []core.Event{},
		shouldFailAfter: -1, // Never fail by default
	}
}

// Connect implements the Transport interface
func (m *MockTransport) Connect(ctx context.Context) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	
	if m.connected {
		return transport.ErrAlreadyConnected
	}
	
	m.connected = true
	return nil
}

// Close implements the Transport interface
func (m *MockTransport) Close() error {
	m.mu.Lock()
	defer m.mu.Unlock()
	
	if !m.connected {
		return transport.ErrNotConnected
	}
	
	m.connected = false
	close(m.eventChan)
	close(m.errorChan)
	return nil
}

// Send implements the Transport interface
func (m *MockTransport) Send(ctx context.Context, event core.Event) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	
	if !m.connected {
		return transport.ErrNotConnected
	}
	
	m.sendCount++
	if m.shouldFailAfter > 0 && m.sendCount > m.shouldFailAfter {
		return transport.ErrConnectionClosed
	}
	
	m.sentEvents = append(m.sentEvents, event)
	return nil
}

// Receive implements the Transport interface
func (m *MockTransport) Receive() <-chan transport.Event {
	return m.eventChan
}

// Errors implements the Transport interface
func (m *MockTransport) Errors() <-chan error {
	return m.errorChan
}

// IsConnected implements the Transport interface
func (m *MockTransport) IsConnected() bool {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.connected
}

// Capabilities implements the Transport interface
func (m *MockTransport) Capabilities() transport.Capabilities {
	return m.capabilities
}

// Health implements the Transport interface
func (m *MockTransport) Health(ctx context.Context) error {
	m.mu.RLock()
	defer m.mu.RUnlock()
	
	if !m.connected {
		return transport.ErrNotConnected
	}
	return nil
}

// Metrics implements the Transport interface
func (m *MockTransport) Metrics() transport.Metrics {
	m.mu.RLock()
	defer m.mu.RUnlock()
	
	return transport.Metrics{
		ConnectionUptime:   time.Hour,
		MessagesSent:       uint64(len(m.sentEvents)),
		MessagesReceived:   0,
		BytesSent:          1024 * uint64(len(m.sentEvents)),
		BytesReceived:      0,
		ErrorCount:         0,
		AverageLatency:     10 * time.Millisecond,
		CurrentThroughput:  100.0,
		ReconnectCount:     0,
	}
}

// SetMiddleware implements the Transport interface
func (m *MockTransport) SetMiddleware(middleware ...transport.Middleware) {
	m.middleware = append(m.middleware, middleware...)
}

// SetFailAfter sets the transport to fail after n sends
func (m *MockTransport) SetFailAfter(n int) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.shouldFailAfter = n
}

// GetSentEvents returns the events that were sent
func (m *MockTransport) GetSentEvents() []core.Event {
	m.mu.RLock()
	defer m.mu.RUnlock()
	
	events := make([]core.Event, len(m.sentEvents))
	copy(events, m.sentEvents)
	return events
}

// MockTransportFactory creates mock transports
type MockTransportFactory struct {
	name      string
	transport *MockTransport
}

// NewMockTransportFactory creates a new mock transport factory
func NewMockTransportFactory(name string, transport *MockTransport) *MockTransportFactory {
	return &MockTransportFactory{
		name:      name,
		transport: transport,
	}
}

// Name returns the factory name
func (f *MockTransportFactory) Name() string {
	return f.name
}

// Create creates a mock transport
func (f *MockTransportFactory) Create(ctx context.Context, config interface{}) (transport.Transport, error) {
	return f.transport, nil
}

// ValidateConfig validates the configuration
func (f *MockTransportFactory) ValidateConfig(config interface{}) error {
	return nil
}

// MockEvent implements a mock event for testing
type MockEvent struct {
	id       string
	eventType string
	data     map[string]interface{}
}

// NewMockEvent creates a new mock event
func NewMockEvent(id, eventType string, data map[string]interface{}) *MockEvent {
	return &MockEvent{
		id:       id,
		eventType: eventType,
		data:     data,
	}
}

// ID implements the Event interface
func (e *MockEvent) ID() string {
	return e.id
}

// Type implements the Event interface
func (e *MockEvent) Type() string {
	return e.eventType
}

// Data implements the Event interface
func (e *MockEvent) Data() map[string]interface{} {
	return e.data
}

// Timestamp implements the Event interface
func (e *MockEvent) Timestamp() time.Time {
	return time.Now()
}

// TestTransportFactory tests the transport factory functionality
func TestTransportFactory(t *testing.T) {
	factory := factory.New()
	
	// Create mock transport
	mockTransport := NewMockTransport("mock", transport.Capabilities{
		Streaming: true,
		Bidirectional: true,
	})
	
	// Register mock factory
	mockFactory := NewMockTransportFactory("mock", mockTransport)
	err := factory.Register(mockFactory)
	if err != nil {
		t.Fatalf("Failed to register mock factory: %v", err)
	}
	
	// Test transport creation
	ctx := context.Background()
	transport, err := factory.Create(ctx, "mock", nil)
	if err != nil {
		t.Fatalf("Failed to create transport: %v", err)
	}
	
	if transport == nil {
		t.Fatal("Created transport is nil")
	}
	
	// Test duplicate registration
	err = factory.Register(mockFactory)
	if err == nil {
		t.Fatal("Expected error for duplicate registration")
	}
	
	// Test unknown transport type
	_, err = factory.Create(ctx, "unknown", nil)
	if err == nil {
		t.Fatal("Expected error for unknown transport type")
	}
}

// TestTransportRegistry tests the transport registry functionality
func TestTransportRegistry(t *testing.T) {
	factory := factory.New()
	registry := factory.NewRegistry(factory)
	
	// Register mock transports
	websocketCaps := transport.Capabilities{
		Streaming: true,
		Bidirectional: true,
		Multiplexing: true,
		Reconnection: true,
		Compression: []transport.CompressionType{transport.CompressionGzip},
		Security: []transport.SecurityFeature{transport.SecurityTLS},
		ProtocolVersion: "1.0",
	}
	
	httpCaps := transport.Capabilities{
		Streaming: false,
		Bidirectional: false,
		Multiplexing: false,
		Reconnection: false,
		Compression: []transport.CompressionType{transport.CompressionGzip},
		Security: []transport.SecurityFeature{transport.SecurityTLS},
		ProtocolVersion: "1.0",
	}
	
	websocketTransport := NewMockTransport("websocket", websocketCaps)
	httpTransport := NewMockTransport("http", httpCaps)
	
	factory.Register(NewMockTransportFactory("websocket", websocketTransport))
	factory.Register(NewMockTransportFactory("http", httpTransport))
	
	registry.RegisterCapabilities("websocket", websocketCaps)
	registry.RegisterCapabilities("http", httpCaps)
	
	registry.SetPriority("websocket", 10)
	registry.SetPriority("http", 5)
	
	// Test transport selection
	ctx := context.Background()
	requirements := factory.Requirements{
		Streaming: true,
		Bidirectional: true,
	}
	
	selected, err := registry.SelectTransport(ctx, requirements)
	if err != nil {
		t.Fatalf("Failed to select transport: %v", err)
	}
	
	if selected != "websocket" {
		t.Fatalf("Expected websocket, got %s", selected)
	}
	
	// Test with requirements that only HTTP meets
	requirements = factory.Requirements{
		Streaming: false,
		Bidirectional: false,
		ExcludedTransports: []string{"websocket"},
	}
	
	selected, err = registry.SelectTransport(ctx, requirements)
	if err != nil {
		t.Fatalf("Failed to select transport: %v", err)
	}
	
	if selected != "http" {
		t.Fatalf("Expected http, got %s", selected)
	}
}

// TestCapabilityNegotiation tests capability negotiation
func TestCapabilityNegotiation(t *testing.T) {
	localCaps := transport.Capabilities{
		Streaming: true,
		Bidirectional: true,
		Compression: []transport.CompressionType{transport.CompressionGzip, transport.CompressionZstd},
		Security: []transport.SecurityFeature{transport.SecurityTLS, transport.SecurityJWT},
		ProtocolVersion: "1.0",
	}
	
	remoteCaps := transport.Capabilities{
		Streaming: true,
		Bidirectional: false,
		Compression: []transport.CompressionType{transport.CompressionGzip},
		Security: []transport.SecurityFeature{transport.SecurityTLS},
		ProtocolVersion: "1.0",
	}
	
	negotiator := capabilities.NewDefaultNegotiator(localCaps)
	
	ctx := context.Background()
	result, err := negotiator.NegotiateCapabilities(ctx, localCaps, remoteCaps)
	if err != nil {
		t.Fatalf("Capability negotiation failed: %v", err)
	}
	
	// Check agreed capabilities
	if !result.Agreed.Streaming {
		t.Error("Expected streaming to be agreed")
	}
	
	if result.Agreed.Bidirectional {
		t.Error("Expected bidirectional to not be agreed")
	}
	
	if len(result.Agreed.Compression) != 1 || result.Agreed.Compression[0] != transport.CompressionGzip {
		t.Error("Expected gzip compression to be agreed")
	}
	
	if len(result.Agreed.Security) != 1 || result.Agreed.Security[0] != transport.SecurityTLS {
		t.Error("Expected TLS security to be agreed")
	}
}

// TestTransportManager tests the transport manager functionality
func TestTransportManager(t *testing.T) {
	// Create configuration
	cfg := &config.Config{
		Primary: "websocket",
		Fallback: []string{"http"},
		Selection: config.SelectionConfig{
			Strategy: "performance",
			HealthCheckInterval: 10 * time.Second,
			FailoverThreshold: 3,
		},
		Global: config.GlobalConfig{
			BufferSize: 100,
		},
	}
	
	// Create factory and registry
	factory := factory.New()
	registry := factory.NewRegistry(factory)
	
	// Register mock transports
	websocketTransport := NewMockTransport("websocket", transport.Capabilities{
		Streaming: true,
		Bidirectional: true,
	})
	
	httpTransport := NewMockTransport("http", transport.Capabilities{
		Streaming: false,
		Bidirectional: false,
	})
	
	factory.Register(NewMockTransportFactory("websocket", websocketTransport))
	factory.Register(NewMockTransportFactory("http", httpTransport))
	
	registry.RegisterCapabilities("websocket", websocketTransport.Capabilities())
	registry.RegisterCapabilities("http", httpTransport.Capabilities())
	
	registry.SetPriority("websocket", 10)
	registry.SetPriority("http", 5)
	
	// Create and start manager
	manager := transport.NewManager(cfg, registry, factory)
	
	ctx := context.Background()
	err := manager.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start manager: %v", err)
	}
	defer manager.Stop()
	
	// Test sending events
	event := NewMockEvent("test-1", "test", map[string]interface{}{"message": "hello"})
	err = manager.Send(ctx, event)
	if err != nil {
		t.Fatalf("Failed to send event: %v", err)
	}
	
	// Verify event was sent
	activeTransport := manager.GetActiveTransport()
	if activeTransport == nil {
		t.Fatal("No active transport")
	}
	
	// Test metrics
	metrics := manager.GetMetrics()
	if metrics.TotalMessagesSent == 0 {
		t.Error("Expected messages sent metric to be > 0")
	}
}

// TestMiddleware tests middleware functionality
func TestMiddleware(t *testing.T) {
	// Create mock transport
	mockTransport := NewMockTransport("mock", transport.Capabilities{})
	
	// Create middleware chain
	metricsMiddleware := middleware.NewMetricsMiddleware()
	retryMiddleware := middleware.NewRetryMiddleware(3, 100*time.Millisecond, 2.0)
	
	chain := middleware.NewChain(metricsMiddleware, retryMiddleware)
	wrappedTransport := chain.Wrap(mockTransport)
	
	// Test connection
	ctx := context.Background()
	err := wrappedTransport.Connect(ctx)
	if err != nil {
		t.Fatalf("Failed to connect: %v", err)
	}
	
	// Test sending events
	event := NewMockEvent("test-1", "test", map[string]interface{}{"message": "hello"})
	err = wrappedTransport.Send(ctx, event)
	if err != nil {
		t.Fatalf("Failed to send event: %v", err)
	}
	
	// Check metrics
	metrics := metricsMiddleware.GetMetrics()
	if metrics.ConnectionAttempts != 1 {
		t.Errorf("Expected 1 connection attempt, got %d", metrics.ConnectionAttempts)
	}
	
	if metrics.SendAttempts != 1 {
		t.Errorf("Expected 1 send attempt, got %d", metrics.SendAttempts)
	}
	
	// Test retry on failure
	mockTransport.SetFailAfter(0) // Fail immediately
	
	err = wrappedTransport.Send(ctx, event)
	if err == nil {
		t.Error("Expected send to fail")
	}
	
	// Should have retried
	if metrics.SendAttempts < 3 {
		t.Errorf("Expected at least 3 send attempts due to retries")
	}
}

// TestFailover tests transport failover functionality
func TestFailover(t *testing.T) {
	// Create configuration with failover
	cfg := &config.Config{
		Primary: "websocket",
		Fallback: []string{"http"},
		Selection: config.SelectionConfig{
			Strategy: "performance",
			FailoverThreshold: 1, // Fail over immediately
		},
		Global: config.GlobalConfig{
			BufferSize: 100,
		},
	}
	
	// Create factory and registry
	factory := factory.New()
	registry := factory.NewRegistry(factory)
	
	// Create transports - websocket will fail, http will work
	websocketTransport := NewMockTransport("websocket", transport.Capabilities{})
	websocketTransport.SetFailAfter(0) // Fail immediately
	
	httpTransport := NewMockTransport("http", transport.Capabilities{})
	
	factory.Register(NewMockTransportFactory("websocket", websocketTransport))
	factory.Register(NewMockTransportFactory("http", httpTransport))
	
	registry.RegisterCapabilities("websocket", websocketTransport.Capabilities())
	registry.RegisterCapabilities("http", httpTransport.Capabilities())
	
	registry.SetPriority("websocket", 10)
	registry.SetPriority("http", 5)
	
	// Create and start manager
	manager := transport.NewManager(cfg, registry, factory)
	
	ctx := context.Background()
	err := manager.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start manager: %v", err)
	}
	defer manager.Stop()
	
	// Send event - should trigger failover
	event := NewMockEvent("test-1", "test", map[string]interface{}{"message": "hello"})
	err = manager.Send(ctx, event)
	
	// Give time for failover to occur
	time.Sleep(100 * time.Millisecond)
	
	// Try sending again - should work with HTTP transport
	err = manager.Send(ctx, event)
	if err != nil {
		t.Fatalf("Failed to send event after failover: %v", err)
	}
	
	// Check metrics for transport switches
	metrics := manager.GetMetrics()
	if metrics.TransportSwitches == 0 {
		t.Error("Expected at least one transport switch")
	}
}

// BenchmarkTransportSwitching benchmarks transport switching performance
func BenchmarkTransportSwitching(b *testing.B) {
	// Setup
	cfg := &config.Config{
		Primary: "websocket",
		Fallback: []string{"http"},
		Global: config.GlobalConfig{
			BufferSize: 1000,
		},
	}
	
	factory := factory.New()
	registry := factory.NewRegistry(factory)
	
	websocketTransport := NewMockTransport("websocket", transport.Capabilities{})
	httpTransport := NewMockTransport("http", transport.Capabilities{})
	
	factory.Register(NewMockTransportFactory("websocket", websocketTransport))
	factory.Register(NewMockTransportFactory("http", httpTransport))
	
	registry.RegisterCapabilities("websocket", websocketTransport.Capabilities())
	registry.RegisterCapabilities("http", httpTransport.Capabilities())
	
	manager := transport.NewManager(cfg, registry, factory)
	
	ctx := context.Background()
	manager.Start(ctx)
	defer manager.Stop()
	
	b.ResetTimer()
	
	// Benchmark switching between transports
	for i := 0; i < b.N; i++ {
		if i%2 == 0 {
			manager.SwitchTransport(ctx, "websocket")
		} else {
			manager.SwitchTransport(ctx, "http")
		}
	}
}

// BenchmarkEventSending benchmarks event sending performance
func BenchmarkEventSending(b *testing.B) {
	// Setup
	mockTransport := NewMockTransport("mock", transport.Capabilities{})
	
	ctx := context.Background()
	mockTransport.Connect(ctx)
	
	event := NewMockEvent("bench-event", "benchmark", map[string]interface{}{
		"data": "benchmark data",
		"size": 1024,
	})
	
	b.ResetTimer()
	
	// Benchmark sending events
	for i := 0; i < b.N; i++ {
		mockTransport.Send(ctx, event)
	}
}